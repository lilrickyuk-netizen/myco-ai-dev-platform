/**
 * Generated TypeScript Client
 * 
 * This file is auto-generated from the OpenAPI specification.
 * Do not edit this file directly.
 */

// Base types
export interface ApiResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
}

export interface ApiError {
  code: string;
  message: string;
  details?: any;
  status: number;
}

export class ApiClientError extends Error {
  constructor(
    public error: ApiError,
    public response?: Response
  ) {
    super(error.message);
    this.name = 'ApiClientError';
  }
}

// Configuration
export interface ApiClientConfig {
  baseUrl?: string;
  headers?: Record<string, string>;
  timeout?: number;
}

// Schema Types
export interface GlobalHealthResponse {
  status?: 'healthy' | 'unhealthy' | 'degraded';
  timestamp?: string;
  version?: string;
  services?: Array<string>;
  environment?: {
    valid?: boolean;
    errors?: Array<string>;
    warnings?: Array<string>;
    missingOptional?: Array<string>;
    database?: string;
  };
  nodeEnv?: string;
}

export interface ReadinessResponse {
  status?: 'ready' | 'degraded';
  services?: {
    database?: 'available' | 'unavailable';
    ai_engine?: 'available' | 'unavailable';
  };
  timestamp?: string;
}

export interface UserInfo {
  id?: string;
  email?: string | null;
  imageUrl?: string;
  firstName?: string | null;
  lastName?: string | null;
}

export interface Project {
  id?: string;
  name?: string;
  description?: string | null;
  template?: string | null;
  templateType?: string;
  templateName?: string;
  status?: 'active' | 'archived' | 'deleted';
  visibility?: 'private' | 'public';
  repositoryUrl?: string | null;
  deployUrl?: string | null;
  createdAt?: string;
  updatedAt?: string;
  isOwner?: boolean;
}

export interface CreateProjectRequest {
  name: string;
  description?: string | null;
  template?: string | null;
  visibility?: 'private' | 'public';
}

export interface UpdateProjectRequest {
  name?: string;
  description?: string | null;
  repositoryUrl?: string | null;
  deployUrl?: string | null;
  status?: 'active' | 'archived' | 'deleted';
  visibility?: 'private' | 'public';
}

export interface FileNode {
  id?: string;
  name?: string;
  path?: string;
  type?: 'file' | 'directory';
  content?: string | null;
  children?: Array<FileNode> | null;
  size?: number;
  lastModified?: string;
  isReadonly?: boolean;
}

export interface FileListResponse {
  files?: Array<FileNode>;
}

export interface CreateFileRequest {
  projectId: string;
  path: string;
  content?: string | null;
  type: 'file' | 'directory';
}

export interface UpdateFileRequest {
  content: string;
}

export interface GenerateRequest {
  prompt: string;
  model?: string | null;
  temperature?: number | null;
  maxTokens?: number | null;
  projectId?: string | null;
  context?: string | null;
}

export interface GenerateResponse {
  content?: string;
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
  };
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: string;
}

export interface ChatRequest {
  sessionId?: string | null;
  messages: Array<ChatMessage>;
  projectId?: string | null;
}

export interface ChatResponse {
  message?: ChatMessage;
  sessionId?: string;
}

export interface ErrorResponse {
  code?: string;
  message?: string;
  details?: any | null;
}

export class ApiClient {
  private baseUrl: string;
  private headers: Record<string, string>;
  private timeout: number;

  constructor(config: ApiClientConfig = {}) {
    this.baseUrl = config.baseUrl || '';
    this.headers = {
      'Content-Type': 'application/json',
      ...config.headers
    };
    this.timeout = config.timeout || 30000;
  }

  setAuthToken(token: string) {
    this.headers['Authorization'] = `Bearer ${token}`;
  }

  removeAuthToken() {
    delete this.headers['Authorization'];
  }

  private async request<T>(
    method: string,
    path: string,
    body?: any,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${path}`;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        method,
        headers: { ...this.headers, ...options.headers },
        body: body ? JSON.stringify(body) : undefined,
        signal: controller.signal,
        ...options
      });

      clearTimeout(timeoutId);

      const responseHeaders: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });

      if (!response.ok) {
        let errorData: ApiError;
        try {
          errorData = await response.json();
        } catch {
          errorData = {
            code: 'unknown_error',
            message: response.statusText || 'Unknown error',
            status: response.status
          };
        }
        throw new ApiClientError(errorData, response);
      }

      const data = response.headers.get('content-type')?.includes('application/json')
        ? await response.json()
        : await response.text();

      return {
        data,
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders
      };
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof ApiClientError) {
        throw error;
      }
      
      if (error instanceof Error && error.name === 'AbortError') {
        throw new ApiClientError({
          code: 'timeout',
          message: 'Request timeout',
          status: 408
        });
      }
      
      throw new ApiClientError({
        code: 'network_error',
        message: error instanceof Error ? error.message : 'Network error',
        status: 0
      });
    }
  }

  // Health endpoints
  async getHealth(options: RequestInit = {}): Promise<ApiResponse<GlobalHealthResponse>> {
    return this.request<GlobalHealthResponse>('GET', '/health', undefined, options);
  }

  async getReady(options: RequestInit = {}): Promise<ApiResponse<ReadinessResponse>> {
    return this.request<ReadinessResponse>('GET', '/ready', undefined, options);
  }

  // Authentication endpoints
  async getUserMe(options: RequestInit = {}): Promise<ApiResponse<UserInfo>> {
    return this.request<UserInfo>('GET', '/user/me', undefined, options);
  }

  // Project endpoints
  async getProjects(options: RequestInit = {}): Promise<ApiResponse<{ projects: Array<Project> }>> {
    return this.request<{ projects: Array<Project> }>('GET', '/projects', undefined, options);
  }

  async createProjects(body: CreateProjectRequest, options: RequestInit = {}): Promise<ApiResponse<Project>> {
    return this.request<Project>('POST', '/projects', body, options);
  }

  async getProjectsById(params: { id: string }, options: RequestInit = {}): Promise<ApiResponse<Project>> {
    return this.request<Project>('GET', `/projects/${params.id}`, undefined, options);
  }

  async updateProjectsById(params: { id: string }, body: UpdateProjectRequest, options: RequestInit = {}): Promise<ApiResponse<Project>> {
    return this.request<Project>('PUT', `/projects/${params.id}`, body, options);
  }

  async deleteProjectsById(params: { id: string }, options: RequestInit = {}): Promise<ApiResponse<{ success: boolean }>> {
    return this.request<{ success: boolean }>('DELETE', `/projects/${params.id}`, undefined, options);
  }

  // Filesystem endpoints
  async getFilesystemByProjectId(params: { projectId: string }, options: RequestInit = {}): Promise<ApiResponse<FileListResponse>> {
    return this.request<FileListResponse>('GET', `/filesystem/${params.projectId}`, undefined, options);
  }

  async createFilesystemFile(body: CreateFileRequest, options: RequestInit = {}): Promise<ApiResponse<FileNode>> {
    return this.request<FileNode>('POST', '/filesystem/file', body, options);
  }

  async getFilesystemFileById(params: { id: string }, options: RequestInit = {}): Promise<ApiResponse<FileNode>> {
    return this.request<FileNode>('GET', `/filesystem/file/${params.id}`, undefined, options);
  }

  async updateFilesystemFileById(params: { id: string }, body: UpdateFileRequest, options: RequestInit = {}): Promise<ApiResponse<FileNode>> {
    return this.request<FileNode>('PUT', `/filesystem/file/${params.id}`, body, options);
  }

  async deleteFilesystemFileById(params: { id: string }, options: RequestInit = {}): Promise<ApiResponse<{ success: boolean }>> {
    return this.request<{ success: boolean }>('DELETE', `/filesystem/file/${params.id}`, undefined, options);
  }

  // AI endpoints
  async createAiGenerate(body: GenerateRequest, options: RequestInit = {}): Promise<ApiResponse<GenerateResponse>> {
    return this.request<GenerateResponse>('POST', '/ai/generate', body, options);
  }

  async createAiChat(body: ChatRequest, options: RequestInit = {}): Promise<ApiResponse<ChatResponse>> {
    return this.request<ChatResponse>('POST', '/ai/chat', body, options);
  }
}

// Default instance
export const apiClient = new ApiClient({
  baseUrl: process.env.NODE_ENV === 'production' 
    ? 'https://myco-ai-dev-platform-d32ldfc82vjkjrpel8hg.lp.dev' 
    : 'http://localhost:4000'
});

export default apiClient;