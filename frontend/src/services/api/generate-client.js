#!/usr/bin/env node

/**
 * OpenAPI TypeScript Client Generator
 * Generates a typed client from the backend OpenAPI specification
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const OPENAPI_SPEC_PATH = '../../../../backend/openapi.yaml';
const OUTPUT_FILE = './client.ts';

function pascalCase(str) {
  return str.replace(/(^\w|[A-Z]|\b\w)/g, (word, index) => {
    return index === 0 ? word.toLowerCase() : word.toUpperCase();
  }).replace(/\s+/g, '');
}

function camelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function generateTypeFromSchema(schema, refs = new Set()) {
  if (!schema) return 'any';
  
  if (schema.$ref) {
    const typeName = schema.$ref.split('/').pop();
    refs.add(typeName);
    return typeName;
  }
  
  if (schema.type === 'string') {
    if (schema.enum) {
      return schema.enum.map(v => `'${v}'`).join(' | ');
    }
    return schema.nullable ? 'string | null' : 'string';
  }
  
  if (schema.type === 'number' || schema.type === 'integer') {
    return schema.nullable ? 'number | null' : 'number';
  }
  
  if (schema.type === 'boolean') {
    return schema.nullable ? 'boolean | null' : 'boolean';
  }
  
  if (schema.type === 'array') {
    const itemType = generateTypeFromSchema(schema.items, refs);
    return `Array<${itemType}>`;
  }
  
  if (schema.type === 'object') {
    if (schema.properties) {
      const props = Object.entries(schema.properties).map(([key, prop]) => {
        const optional = !schema.required?.includes(key) ? '?' : '';
        const type = generateTypeFromSchema(prop, refs);
        return `  ${key}${optional}: ${type};`;
      }).join('\n');
      return `{\n${props}\n}`;
    }
    return 'Record<string, any>';
  }
  
  return 'any';
}

function generateInterface(name, schema, refs) {
  const type = generateTypeFromSchema(schema, refs);
  
  if (type.startsWith('{')) {
    return `export interface ${name} ${type}`;
  } else {
    return `export type ${name} = ${type};`;
  }
}

function getPathParams(path) {
  const matches = path.match(/\{([^}]+)\}/g);
  return matches ? matches.map(m => m.slice(1, -1)) : [];
}

function generateMethodName(method, path) {
  const pathParts = path.split('/').filter(p => p && !p.startsWith('{'));
  const methodMap = {
    'get': pathParts.length > 1 ? `get${pascalCase(pathParts.join(' '))}` : 'get',
    'post': pathParts.length > 1 ? `create${pascalCase(pathParts.join(' '))}` : 'create',
    'put': pathParts.length > 1 ? `update${pascalCase(pathParts.join(' '))}` : 'update',
    'delete': pathParts.length > 1 ? `delete${pascalCase(pathParts.join(' '))}` : 'delete'
  };
  
  return methodMap[method] || camelCase(`${method}-${pathParts.join('-')}`);
}

function generateClient() {
  console.log('Generating TypeScript client from OpenAPI spec...');
  
  // Read OpenAPI spec
  const specPath = path.resolve(__dirname, OPENAPI_SPEC_PATH);
  if (!fs.existsSync(specPath)) {
    throw new Error(`OpenAPI spec not found at ${specPath}`);
  }
  
  const spec = yaml.load(fs.readFileSync(specPath, 'utf8'));
  
  const client = [];
  const refs = new Set();
  
  // Generate header
  client.push(`/**
 * Generated TypeScript Client
 * 
 * This file is auto-generated from the OpenAPI specification.
 * Do not edit this file directly.
 */

// Base types
export interface ApiResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
}

export interface ApiError {
  code: string;
  message: string;
  details?: any;
  status: number;
}

export class ApiClientError extends Error {
  constructor(
    public error: ApiError,
    public response?: Response
  ) {
    super(error.message);
    this.name = 'ApiClientError';
  }
}

// Configuration
export interface ApiClientConfig {
  baseUrl?: string;
  headers?: Record<string, string>;
  timeout?: number;
}
`);

  // Generate interfaces from components
  if (spec.components?.schemas) {
    client.push('\n// Schema Types');
    for (const [name, schema] of Object.entries(spec.components.schemas)) {
      client.push(generateInterface(name, schema, refs));
      client.push('');
    }
  }

  // Generate client class
  client.push(`
export class ApiClient {
  private baseUrl: string;
  private headers: Record<string, string>;
  private timeout: number;

  constructor(config: ApiClientConfig = {}) {
    this.baseUrl = config.baseUrl || '';
    this.headers = {
      'Content-Type': 'application/json',
      ...config.headers
    };
    this.timeout = config.timeout || 30000;
  }

  setAuthToken(token: string) {
    this.headers['Authorization'] = \`Bearer \${token}\`;
  }

  removeAuthToken() {
    delete this.headers['Authorization'];
  }

  private async request<T>(
    method: string,
    path: string,
    body?: any,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = \`\${this.baseUrl}\${path}\`;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        method,
        headers: { ...this.headers, ...options.headers },
        body: body ? JSON.stringify(body) : undefined,
        signal: controller.signal,
        ...options
      });

      clearTimeout(timeoutId);

      const responseHeaders: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });

      if (!response.ok) {
        let errorData: ApiError;
        try {
          errorData = await response.json();
        } catch {
          errorData = {
            code: 'unknown_error',
            message: response.statusText || 'Unknown error',
            status: response.status
          };
        }
        throw new ApiClientError(errorData, response);
      }

      const data = response.headers.get('content-type')?.includes('application/json')
        ? await response.json()
        : await response.text();

      return {
        data,
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders
      };
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof ApiClientError) {
        throw error;
      }
      
      if (error.name === 'AbortError') {
        throw new ApiClientError({
          code: 'timeout',
          message: 'Request timeout',
          status: 408
        });
      }
      
      throw new ApiClientError({
        code: 'network_error',
        message: error.message || 'Network error',
        status: 0
      });
    }
  }
`);

  // Generate methods for each endpoint
  if (spec.paths) {
    for (const [path, pathItem] of Object.entries(spec.paths)) {
      for (const [method, operation] of Object.entries(pathItem)) {
        if (!['get', 'post', 'put', 'delete', 'patch'].includes(method)) continue;

        const methodName = generateMethodName(method, path);
        const pathParams = getPathParams(path);
        const hasRequestBody = operation.requestBody;
        const responseSchema = operation.responses?.['200']?.content?.['application/json']?.schema;
        
        // Generate method signature
        const params = [];
        
        // Path parameters
        if (pathParams.length > 0) {
          params.push(`params: { ${pathParams.map(p => `${p}: string`).join('; ')} }`);
        }
        
        // Request body
        if (hasRequestBody) {
          const bodySchema = hasRequestBody.content?.['application/json']?.schema;
          if (bodySchema) {
            const bodyType = generateTypeFromSchema(bodySchema, refs);
            params.push(`body: ${bodyType}`);
          } else {
            params.push('body: any');
          }
        }
        
        // Options
        params.push('options: RequestInit = {}');
        
        // Return type
        let returnType = 'any';
        if (responseSchema) {
          returnType = generateTypeFromSchema(responseSchema, refs);
        }
        
        // Build URL with path parameters
        let urlBuilder = `'${path}'`;
        for (const param of pathParams) {
          urlBuilder = urlBuilder.replace(`{${param}}`, `\${params.${param}}`);
        }
        
        client.push(`
  async ${methodName}(${params.join(', ')}): Promise<ApiResponse<${returnType}>> {
    return this.request<${returnType}>(
      '${method.toUpperCase()}',
      ${urlBuilder},
      ${hasRequestBody ? 'body' : 'undefined'},
      options
    );
  }`);
      }
    }
  }

  client.push(`
}

// Default instance
export const apiClient = new ApiClient({
  baseUrl: process.env.NODE_ENV === 'production' 
    ? 'https://myco-ai-dev-platform-d32ldfc82vjkjrpel8hg.lp.dev' 
    : 'http://localhost:4000'
});

export default apiClient;
`);

  // Write the generated client
  const outputPath = path.resolve(__dirname, OUTPUT_FILE);
  fs.writeFileSync(outputPath, client.join('\n'));
  
  console.log(`‚úÖ Generated TypeScript client at ${outputPath}`);
  console.log(`üìä Generated ${refs.size} type definitions`);
}

// Run if called directly
if (require.main === module) {
  try {
    generateClient();
  } catch (error) {
    console.error('‚ùå Failed to generate client:', error.message);
    process.exit(1);
  }
}

module.exports = { generateClient };