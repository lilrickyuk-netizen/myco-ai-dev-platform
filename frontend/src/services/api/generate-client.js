#!/usr/bin/env node

/**
 * Generate typed API client from OpenAPI specification
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const OPENAPI_SPEC_PATH = path.join(__dirname, '../../../../backend/openapi.yaml');
const OUTPUT_DIR = path.join(__dirname);
const CLIENT_OUTPUT = path.join(OUTPUT_DIR, 'client.ts');
const TYPES_OUTPUT = path.join(OUTPUT_DIR, 'types.ts');

async function generateClient() {
  console.log('üîß Generating typed API client from OpenAPI spec...');
  
  try {
    // Check if OpenAPI spec exists
    if (!fs.existsSync(OPENAPI_SPEC_PATH)) {
      throw new Error(`OpenAPI spec not found at: ${OPENAPI_SPEC_PATH}`);
    }

    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    console.log('üìã Generating TypeScript types...');
    
    // Generate TypeScript types using openapi-typescript
    try {
      execSync(`npx openapi-typescript "${OPENAPI_SPEC_PATH}" --output "${TYPES_OUTPUT}"`, {
        stdio: 'inherit'
      });
      console.log('‚úÖ Types generated successfully');
    } catch (error) {
      console.error('‚ùå Failed to generate types:', error.message);
      throw error;
    }

    console.log('üî® Generating API client...');
    
    // Generate the client implementation
    const clientCode = generateClientImplementation();
    fs.writeFileSync(CLIENT_OUTPUT, clientCode);
    
    console.log('‚úÖ API client generated successfully');
    console.log(`üìÑ Types: ${TYPES_OUTPUT}`);
    console.log(`üéØ Client: ${CLIENT_OUTPUT}`);
    
  } catch (error) {
    console.error('‚ùå Client generation failed:', error.message);
    process.exit(1);
  }
}

function generateClientImplementation() {
  return `/**
 * Auto-generated API client for MYCO AI Dev Platform
 * 
 * This file is generated automatically from the OpenAPI specification.
 * Do not edit this file directly.
 */

import { z } from 'zod';
import type { paths, components } from './types';

// Base configuration
const API_BASE_URL = process.env.REACT_APP_API_URL || '';
const DEFAULT_TIMEOUT = 30000;

// Type definitions from OpenAPI spec
export type ApiPaths = paths;
export type ApiComponents = components;

// Request/Response types
type ApiResponse<T> = {
  data: T;
  status: number;
  headers: Record<string, string>;
};

type ApiError = {
  code: string;
  message: string;
  details?: any;
  status: number;
};

// HTTP methods
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

// Request options
interface RequestOptions {
  timeout?: number;
  signal?: AbortSignal;
  headers?: Record<string, string>;
}

// Zod schemas for runtime validation
const ErrorResponseSchema = z.object({
  code: z.string(),
  message: z.string(),
  details: z.any().optional(),
});

const UserInfoSchema = z.object({
  id: z.string(),
  email: z.string().email().nullable(),
  imageUrl: z.string().url(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
});

const ProjectSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  template: z.string().nullable(),
  templateType: z.string(),
  templateName: z.string(),
  status: z.enum(['active', 'archived', 'deleted']),
  visibility: z.enum(['private', 'public']),
  repositoryUrl: z.string().url().nullable(),
  deployUrl: z.string().url().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
  isOwner: z.boolean(),
});

const FileNodeSchema: z.ZodType<any> = z.lazy(() => z.object({
  id: z.string(),
  name: z.string(),
  path: z.string(),
  type: z.enum(['file', 'directory']),
  content: z.string().nullable(),
  children: z.array(FileNodeSchema).nullable(),
  size: z.number().min(0),
  lastModified: z.string(),
  isReadonly: z.boolean().optional(),
}));

const GenerateResponseSchema = z.object({
  content: z.string(),
  usage: z.object({
    promptTokens: z.number(),
    completionTokens: z.number(),
    totalTokens: z.number(),
  }).optional(),
});

const ChatMessageSchema = z.object({
  id: z.string(),
  role: z.enum(['user', 'assistant', 'system']),
  content: z.string(),
  timestamp: z.string(),
});

class ApiClient {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;

  constructor(baseUrl: string = API_BASE_URL) {
    this.baseUrl = baseUrl.replace(/\\/$/, '');
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
  }

  setAuthToken(token: string) {
    this.defaultHeaders['Authorization'] = \`Bearer \${token}\`;
  }

  clearAuthToken() {
    delete this.defaultHeaders['Authorization'];
  }

  private async request<T>(
    method: HttpMethod,
    endpoint: string,
    data?: any,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const url = \`\${this.baseUrl}\${endpoint}\`;
    const controller = new AbortController();
    const signal = options.signal || controller.signal;
    
    // Set timeout
    const timeout = options.timeout || DEFAULT_TIMEOUT;
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        method,
        headers: {
          ...this.defaultHeaders,
          ...options.headers,
        },
        body: data ? JSON.stringify(data) : undefined,
        signal,
      });

      clearTimeout(timeoutId);

      const responseHeaders: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });

      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
          ErrorResponseSchema.parse(errorData);
        } catch {
          errorData = {
            code: 'unknown_error',
            message: response.statusText || 'Unknown error occurred',
          };
        }

        throw new ApiError({
          ...errorData,
          status: response.status,
        });
      }

      let responseData;
      try {
        responseData = await response.json();
      } catch {
        responseData = null;
      }

      return {
        data: responseData,
        status: response.status,
        headers: responseHeaders,
      };
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof ApiError) {
        throw error;
      }
      
      if (error.name === 'AbortError') {
        throw new ApiError({
          code: 'timeout',
          message: 'Request timeout',
          status: 408,
        });
      }

      throw new ApiError({
        code: 'network_error',
        message: error.message || 'Network error occurred',
        status: 0,
      });
    }
  }

  // Health endpoints
  async getHealth(): Promise<ApiResponse<components['schemas']['GlobalHealthResponse']>> {
    return this.request('GET', '/health');
  }

  async getReadiness(): Promise<ApiResponse<components['schemas']['ReadinessResponse']>> {
    return this.request('GET', '/ready');
  }

  // Authentication endpoints
  async getCurrentUser(): Promise<ApiResponse<components['schemas']['UserInfo']>> {
    const response = await this.request('GET', '/user/me');
    UserInfoSchema.parse(response.data);
    return response;
  }

  // Project endpoints
  async getProjects(): Promise<ApiResponse<{ projects: components['schemas']['Project'][] }>> {
    const response = await this.request('GET', '/projects');
    z.object({ projects: z.array(ProjectSchema) }).parse(response.data);
    return response;
  }

  async createProject(
    data: components['schemas']['CreateProjectRequest']
  ): Promise<ApiResponse<components['schemas']['Project']>> {
    const response = await this.request('POST', '/projects', data);
    ProjectSchema.parse(response.data);
    return response;
  }

  async getProject(id: string): Promise<ApiResponse<components['schemas']['Project']>> {
    const response = await this.request('GET', \`/projects/\${id}\`);
    ProjectSchema.parse(response.data);
    return response;
  }

  async updateProject(
    id: string,
    data: components['schemas']['UpdateProjectRequest']
  ): Promise<ApiResponse<components['schemas']['Project']>> {
    const response = await this.request('PUT', \`/projects/\${id}\`, data);
    ProjectSchema.parse(response.data);
    return response;
  }

  async deleteProject(id: string): Promise<ApiResponse<{ success: boolean }>> {
    return this.request('DELETE', \`/projects/\${id}\`);
  }

  // File system endpoints
  async getProjectFiles(projectId: string): Promise<ApiResponse<components['schemas']['FileListResponse']>> {
    const response = await this.request('GET', \`/filesystem/\${projectId}\`);
    z.object({ files: z.array(FileNodeSchema) }).parse(response.data);
    return response;
  }

  async getFile(id: string): Promise<ApiResponse<components['schemas']['FileNode']>> {
    const response = await this.request('GET', \`/filesystem/file/\${id}\`);
    FileNodeSchema.parse(response.data);
    return response;
  }

  async createFile(
    data: components['schemas']['CreateFileRequest']
  ): Promise<ApiResponse<components['schemas']['FileNode']>> {
    const response = await this.request('POST', '/filesystem/file', data);
    FileNodeSchema.parse(response.data);
    return response;
  }

  async updateFile(
    id: string,
    data: components['schemas']['UpdateFileRequest']
  ): Promise<ApiResponse<components['schemas']['FileNode']>> {
    const response = await this.request('PUT', \`/filesystem/file/\${id}\`, data);
    FileNodeSchema.parse(response.data);
    return response;
  }

  async deleteFile(id: string): Promise<ApiResponse<{ success: boolean }>> {
    return this.request('DELETE', \`/filesystem/file/\${id}\`);
  }

  // AI endpoints
  async generateText(
    data: components['schemas']['GenerateRequest']
  ): Promise<ApiResponse<components['schemas']['GenerateResponse']>> {
    const response = await this.request('POST', '/ai/generate', data);
    GenerateResponseSchema.parse(response.data);
    return response;
  }

  async chat(
    data: components['schemas']['ChatRequest']
  ): Promise<ApiResponse<components['schemas']['ChatResponse']>> {
    const response = await this.request('POST', '/ai/chat', data);
    z.object({
      message: ChatMessageSchema,
      sessionId: z.string(),
    }).parse(response.data);
    return response;
  }
}

// Custom error class
class ApiError extends Error {
  code: string;
  status: number;
  details?: any;

  constructor({ code, message, status, details }: {
    code: string;
    message: string;
    status: number;
    details?: any;
  }) {
    super(message);
    this.name = 'ApiError';
    this.code = code;
    this.status = status;
    this.details = details;
  }

  isValidationError(): boolean {
    return this.status === 422 || this.code === 'invalid_argument';
  }

  isAuthError(): boolean {
    return this.status === 401 || this.code === 'unauthenticated';
  }

  isForbiddenError(): boolean {
    return this.status === 403 || this.code === 'permission_denied';
  }

  isNotFoundError(): boolean {
    return this.status === 404 || this.code === 'not_found';
  }

  isRateLimitError(): boolean {
    return this.status === 429 || this.code === 'resource_exhausted';
  }

  isServerError(): boolean {
    return this.status >= 500;
  }
}

// Create and export default client instance
const apiClient = new ApiClient();

export { ApiClient, ApiError, apiClient as default };
export type { ApiResponse, RequestOptions };
`;
}

// Run if called directly
if (require.main === module) {
  generateClient();
}

module.exports = { generateClient };